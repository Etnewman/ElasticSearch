{"description":"Loginsight pipeline provided by Enterprise Services","pipeline":"input {
    tcp {
        port => 5050
        codec => multiline {
            pattern => \"^<\\d+>\"
            negate => true
            what => \"previous\"
            max_lines => 1000
        }
    }
}

filter {


    # Copy original data and clear hostname
    mutate {
        copy => { \"@timestamp\" => \"[event][created]\" }
        copy => { \"message\" => \"[event][original]\" }
        id => \"mod_orig\"
    }

    # Line feeds can cause an issue in parsing data so remove them (Left in event.orignal)
    mutate {
        gsub => [ \"message\", \"\
\", \"\" ]
    }

 if [message] !~ /^<\\d+>/ {
        #drop {}
        mutate {
            add_tag => [\"dnt_par\"]
        }
    }

    if [host] {
        mutate {
            rename => { \"host\" => \"[observer][host]\" }
            copy => { \"[observer][host]\" => \"[observer][hostname]\" }
            add_field => { \"[log][source][address]\" => \"%{[observer][host]}:%{[port]}\" }
            add_field => { \"[observer][type]\" => \"VMWare vRealize Log Insight\" }
            remove_field => [ \"host\", \"port\" ]
        }
    }


    # Add Orignating Site to document
    mutate {
        add_field => { \"DCGS_Site\" => \"${SITE}\" }
        add_field => { \"DCGS_Site_Name\" => \"${SITELOC}\" }
        add_field => { \"[geo][name]\" => \"${SITELOC}\" }
        add_tag => [ \"loginsight\" ]
    }
    translate {
        field => \"DCGS_Site_Name\"
        destination => \"[geo][location]\"
        override => \"true\"
        fallback => \"0,0\"
        dictionary_path => '/etc/logstash/dictionaries/site_coordinates.yml'
    }
    # Add time of ingest to event
    ruby {
        code => '
            event.set(\"[event][ingested]\", Time.now())
        '
    }


    if \"dnt_par\" not in [tags] {

        # Parse the header portion of event for syslog priority code, syslog version, and date
        grok {
            match => {
                \"message\" => [
                    \"^(?:<(?<[log][syslog][priority]>[0-9]{1,3})>)(?:(?<[log][syslog][version]>[0-9]{1,2}))? ?(?:%{SYSLOGTIMESTAMP:ts}|%{TIMESTAMP_ISO8601:ts}|(?<ts>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(UTC)?)|(?<ts>[a-zA-Z]{3}\\s+[0-9]{1,2}\\s[0-9]{2}:[0-9]{2}:[0-9]{2}))( I)? %{GREEDYDATA:payload_msg}\"
                ]
            }
            add_tag => [ \"header_parsed0\" ]
            id => \"parse_header0\"
            tag_on_failure => [ \"malformed\" ]
        }

        if \"malformed\" not in [tags] {
            # Parse event for hostname, process name, and pid
            if \"header_parsed0\" in [tags] {
                grok {
                    match => {
                        \"payload_msg\" => [
                            \"^%{IPORHOST:[host][name]} (?:-|\\[?%{PROG:[process][name]}\\]?) +(?:-|(?<[process][pid]>[0-9]{1,8})) +(?:-|%{DATA:[log][syslog][msgid]}) +(?:-|\\[%{DATA:payload_sd}\\]) +%{GREEDYDATA:payload_msg1}\",
                            \"^%{IPORHOST:[host][name]}? (?:%{PROG:[process][name]})(?:\\[(?<[process][pid]>[0-9]{1,8})\\]):? +%{GREEDYDATA:payload_msg1}\",
                            \"^%{IPORHOST:[host][name]} (?:%{PROG:[process][name]})\\[?\\]?: +%{GREEDYDATA:payload_msg1}\",
                            \"^%{IPORHOST:[host][name]} (?:%{PROG:[process][name]})?\\[?\\]? +%{GREEDYDATA:payload_msg1}\",
                            \"^%{IPORHOST:[host][name]}\\(id[0-9]\\) (?:%{PROG:[process][name]}) +(?<[process][pid]>[0-9]{1,8}) - - +%{GREEDYDATA:payload_msg1}\",
                            \"^\\[[A-Z]{2} %{IPORHOST:[host][name]} lacp: [A-Z]{2}\\]%{GREEDYDATA}\",
                            \"^%{IPORHOST:[host][name]} +%{GREEDYDATA:payload_msg1}\"
                        ]
                    }
                    add_tag => [ \"body_parsed0\" ]
                    id => \"parse_body0\"
                }
            }
            if [Log][time] {
                mutate {
                    remove_field => [ \"[Log][time]\" ]
                }
            }

            # Check to see if this is an agent generated message
            if [payload_sd] =~ /^.*@/ {
                grok {
                    match => {
                        \"payload_sd\" => \"%{DATA:[log][syslog][sd-id]} %{GREEDYDATA}\"
                    }
                }

                kv {
                    source => \"payload_sd\"
                    target => \"Log\"
                    transform_key => \"lowercase\"
                }

                # Create log.facility and log.level, if severity exists in Agent data use that for level
                if [Log][severity] and [Log][severity] !~ /^pool.*/ and [Log][severity] !~ /^POST.*/ and [Log][severity] !~ /^GET.*/ {
                    mutate {
                        copy => { \"[log][syslog][facility][name]\" => \"[log][facility]\" }
                        copy => { \"[Log][severity]\" => \"[log][level]\" }
                        add_tag => [ \"log-updated\" ]
                    }
                }
            }

            # Parse syslog priority code Log.pri_severity: * OR Log.pri_facility :*
            if [Log][pri_severity] and [Log][pri_facility] {
                 ruby {
                    code => \"
                        event.set('[log][syslog][priority]', event.get('[Log][pri_facility]').to_i * 8 + event.get('[Log][pri_severity]').to_i )
                    \"
                }
            }

            if [log][syslog][priority] {
                syslog_pri {
                    ecs_compatibility => v8
                }

                if ! [log][level] {
                    mutate {
                        copy => { \"[log][syslog][facility][name]\" => \"[log][facility]\" }
                        copy => { \"[log][syslog][severity][name]\" => \"[log][level]\" }
                    }
                }

                # Add severity code to event
                if ![event][severity] {
                    mutate {
                        copy => { \"[log][syslog][severity][code]\" => \"[event][severity]\" }
                    }
                }
            }
            else {
                mutate {
                    add_tag => [ \"no_syslog_priority\" ]
                }
            }

            if \"UTC\" in [ts] {
                mutate {
                    gsub => [ \"ts\", \"UTC\", \".000Z\" ]
                }
            }

            # Parse auditd events events by formatting event and adding pipeline info
            if [process][name] in [ \"audispd\", \"audit_protocol\", \"auditd\" ] {
            #    dissect {
            #        mapping => {
            #            \"payload_msg1\" => \"node=%{[host][hostname]} %{payload_msg1}\"
            #        }
            #    }

                if [auditd][log][addr] == \"UNKNOWN\" {
                    mutate {
                        remove_field => [ \"[auditd][log][addr]\" ]
                    }
                }

                if [payload_msg1] =~ /msg='op/ {
                    grok {
                        match => {
                            \"payload_msg1\" => \"%{GREEDYDATA}msg='op=%{DATA:[auditd][log][op]} %{GREEDYDATA}\"
                        }
                    }
                }

                # Ensure metadata fields for auditd events are added
                mutate {
                    add_field => { \"[@metadata][pipeline]\" => \"filebeat-${VER}-auditd-log-pipeline\" }
                    add_field => { \"[@metadata][index]\" => \"dcgs-audits_syslog-iaas-ent-${SITENUM}\" }
                    add_field => { \"[event][module]\" => \"auditd\" }
                    add_field => { \"[event][dataset]\" => \"auditd.log\" }
                    id => \"auditd_parse\"
                    add_tag => [ \"auditd_parsed\" ]
                    replace => { \"payload_msg1\" => \"type=%{payload_msg1}\" }
                }
            }
            # Parse iptables events by formatting event and adding pipeline info
            else if [process][name] in [ \"kernel\", \"firewall\" ] and [payload_msg1] =~ /^\\[(IPTABLES|default|DEFAULT|elastic)\\]/ {
                grok {
                    match => {
                        \"payload_msg1\" => \"%{GREEDYDATA:[iptables][log_prefix]}IN=%{GREEDYDATA}\"
                        add_tag => [ \"pnfwkernel_parsed\" ]
                    }
                }

                if [iptables][log_prefix] =~ /DROP/ {
                    mutate {
                        add_field => { \"[iptables][action]\" => \"drop\" }
                        add_field => { \"[event][outcome]\" => \"deny\" }
                        add_field => { \"[event][action]\" => \"firewall-deny\" }
                    }
                }

                # Ensure metadata fields for iptables or firewall events are added, includes specifics for VMWare \"firewall\"
                if [process][name] == \"kernel\" {
                    mutate {
                        rename => { \"[process][name]\" => \"[event][provider]\" }
                        add_field => { \"[process][name]\" => \"iptables\" }
                        id => \"iptable_parse\"
                        add_tag => [ \"iptable_parsed\" ]
                    }
                }
                if [process][name] == \"firewall\" {
                    mutate {
                        add_field => { \"comment\" => \"Using iptables logs pipeline due to its similarity with VMWare firewall logs\" }
                        id => \"firewall_parse\"
                        add_tag => [ \"firewall_parsed\" ]
                    }
                }

                mutate {
                    copy => { \"ts\" => \"[iptables][raw_date]\" }
                    add_field => { \"[event][kind]\" => \"alert\" }
                    add_field => { \"[event][module]\" => \"iptables\" }
                    add_field => { \"[event][dataset]\" => \"iptables.log\" }
                    add_field => { \"[@metadata][pipeline]\" => \"filebeat-${VER}-iptables-log-pipeline\" }
                    add_field => { \"[@metadata][index]\" => \"dcgs-iptables-iaas-ent\" }
                }
            }

            # Fix timestamp
            date {
                match => [ \"ts\", \"MMM dd HH:mm:ss\", \"MMM d HH:mm:ss\", \"MMM  d HH:mm:ss\", \"ISO8601\" ]
                target => \"@timestamp\"
            }


            # Clean up unused fields and move processed event message to message field
            if [payload_msg1] {
                mutate {
                    rename => { \"payload_msg1\" => \"message\" }
                    remove_field => [ \"payload_msg\" ]
                    add_tag => [ \"payload_msg1-to-message\" ]
                }
            }
            else {
                mutate {
                    rename => { \"payload_msg\" => \"message\" }
                    add_tag => [ \"payload_msg-to-message\" ]
                }
            }

            mutate {
        #        rename => { \"kv_payload\" => \"%{[process][name]}\" }
                id => \"clean_up\"
                remove_field => [ \"payload_msg\", \"payload_sd\", \"ts\" ]
                lowercase => [ \"[log][level]\", \"[process][name]\", \"[host][name]\" ]
            }

            if ![host][hostname] {
                mutate {
                    copy => { \"[host][name]\" => \"[host][hostname]\" }
                }
            }

            if [log][level] == \"info\" {
                mutate {
                    update => { \"[log][level]\" =>  \"informational\"}
                    add_tag => [ \"Updated-level\" ]
                }
            }
            else if [log][level] == \"err\" {
                mutate {
                    update => { \"[log][level]\" => \"error\" }
                }
            }
            else if [log][level] == \"warn\" {
                mutate {
                    update => { \"[log][level]\" => \"warning\" }
                }
            }
            # Parse authentication logs from sudo, sshd, and su
            if [process][name] in [ \"sshd\", \"sudo\", \"su\", \"systemd-logind\" ] {
                grok {
                    match => {
                        \"payload_msg1\" => [
                            \"%{DATA:[system][auth][module]}\\(sshd:auth\\): %{DATA:[system][auth][ssh][event]} %{DATA:[system][auth][ssh][outcome]}; logname=%{DATA:[system][auth][ssh][logname]}? uid=%{NUMBER:[system][auth][ssh][uid]}? euid=%{NUMBER:[system][auth][ssh][euid]}? tty=%{DATA:[system][auth][ssh][tty]}? ruser=%{DATA:[system][auth][ssh][remote_user]}? rhost=%{DATA:[system][auth][ssh][remote_host]}? user=%{GREEDYDATA:[system][auth][ssh][user]}?\",
                            \"%{DATA:[system][auth][module]}\\(sudo:auth\\): %{DATA:[system][auth][sudo][event]} %{DATA:[system][auth][sudo][outcome]}; logname=%{DATA:[system][auth][sudo][logname]}? uid=%{NUMBER:[system][auth][sudo][uid]}? euid=%{NUMBER:[system][sudo][ssh][euid]}? tty=%{DATA:[system][auth][sudo][tty]}? ruser=%{DATA:[system][auth][sudo][remote_user]}? rhost=%{DATA:[system][auth][sudo][remote_host]}? user=%{GREEDYDATA:[system][auth][sudo][user]}?\",
                            \"%{DATA:[system][auth][ssh][event]} %{DATA:[system][auth][ssh][method]} for (invalid user )?%{DATA:[user][name]} from %{IPORHOST:[source][ip]} port %{NUMBER:[source][port]:long} ssh2(: %{GREEDYDATA:[system][auth][ssh][signature]})?\",
                            \"%{DATA:[system][auth][ssh][event]} user %{DATA:[user][name]} from %{IPORHOST:[source][ip]}\",
                            \"\\s*%{DATA:[user][name]} :( %{DATA:[system][auth][sudo][error]} ;)? TTY=%{DATA:[system][auth][sudo][tty]} ; PWD=%{DATA:[system][auth][sudo][pwd]} ; USER=%{DATA:[system][auth][sudo][user]} ; COMMAND=%{GREEDYDATA:[system][auth][sudo][command]}\",
                            \"new group: name=%{DATA:[group][name]}, GID=%{NUMBER:[group][id]}\",
                            \"new user: name=%{DATA:[user][name]}, UID=%{NUMBER:[user][id]}, GID=%{NUMBER:[group][id]}, home=%{DATA:[system][auth][useradd][home]}, shell=%{DATA:[system][auth][useradd][shell]}$\",
                            \"%{DATA:[system][auth][ssh][event]} from %{IP:[source][ip]}\",
                            \"%{GREEDYDATA:payload_msg2}\"
                        ]
                    }
                    add_tag => [ \"sshsudo_payload_msg1\" ]
                }

                if ![system][auth][sudo][event] {
                    if [system][auth][ssh][event] not in [ \"success\", \"failure\" ] {
                        translate {
                            field => \"[system][auth][ssh][event]\"
                            destination => \"[system][auth][ssh][outcome]\"
                            dictionary => {
                                \"Accepted\" => \"success\"
                                \"Failed\" => \"failure\"
                                \"Invalid\" => \"failure\"
                            }
                        }
                        mutate {
                            replace => { \"[system][auth][ssh][event]\" => \"authentication\" }
                        }
                    }
                }

                if ![system][auth][ssh][event] {
                    if [system][auth][sudo][event] not in [ \"success\", \"failure\", \"Did not\" ] {
                        translate {
                            field => \"[system][auth][sudo][event]\"
                            destination => \"[system][auth][sudo][outcome]\"
                            dictionary => {
                                \"Did not receive identification string\" => \"failure\"
                                \"Accepted\" => \"success\"
                                \"Failed\" => \"failure\"
                                \"Invalid\" => \"failure\"
                            }
                        }
                        mutate {
                            replace => { \"[system][auth][sudo][event]\" => \"authentication\" }
                        }
                    }
                }

                if [system][auth][ssh][outcome] {
                    mutate {
                    add_field => { \"[event][type]\" => \"authentication_%{[system][auth][ssh][outcome]}\" }
                    }
                }

                if [system][auth][ssh][event] {
                    mutate {
                        copy => { \"[system][auth][ssh][dropped_ip]\" => \"[source][ip]\" }
                        copy => { \"[system][auth][ssh][event]\" => \"[event][category]\" }
                        copy => { \"[system][auth][ssh][outcome]\" => \"[event][outcome]\" }
                        copy => { \"[system][auth][ssh][logname]\" => \"[user][logname]\" }
                        copy => { \"[system][auth][ssh][uid]\" => \"[user][id]\" }
                        copy => { \"[system][auth][ssh][euid]\" => \"[user][effective][id]\" }
                        copy => { \"[system][auth][ssh][tty]\" => \"[user][terminal]\" }
                        copy => { \"[system][auth][ssh][remote_user]\" => \"[user][remote][name]\" }
                        copy => { \"[system][auth][ssh][remote_host]\" => \"[source][Host]\" }
                        copy => { \"[system][auth][ssh][user]\" => \"[user][name]\" }
                    }
                }

                if \"[system][auth][sudo][event]\" {
                    mutate {
                        copy => { \"[system][auth][sudo][event]\" => \"[event][category]\" }
                        copy => { \"[system][auth][sudo][outcome]\" => \"[event][outcome]\" }
                        copy => { \"[system][auth][sudo][logname]\" => \"[user][logname]\" }
                        copy => { \"[system][auth][sudo][uid]\" => \"[user][id]\" }
                        copy => { \"[system][auth][sudo][euid]\" => \"[user][effective][id]\" }
                        copy => { \"[system][auth][sudo][tty]\" => \"[user][terminal]\" }
                        copy => { \"[system][auth][sudo][remote_user]\" => \"[user][remote][name]\" }
                        copy => { \"[system][auth][sudo][remote_host]\" => \"[source][Host]\" }
                        copy => { \"[system][auth][sudo][user]\" => \"[user][name]\" }
                    }
                }

                mutate  {
                    #sudo and ssh events should go into protected audits_syslog
                    add_field => { \"[@metadata][pipeline]\" => \"filebeat-${VER}-auditd-log-pipeline\" }
                    add_field => { \"[@metadata][index]\" => \"dcgs-audits_syslog-iaas-ent-${SITENUM}\" }
                    add_field => { \"[event][module]\" => \"system\" }
                    add_field => { \"[event][dataset]\" => \"system.auth\" }
                    add_tag => [ \"auth_parsed\" ]
                    id => \"auth_parse\"
                }
           }
        }
    }

    if \"_grokparsefailure\" in [tags] {
        mutate {
            add_tag => [ \"dropped-loginsight\" ]
        }
        drop {}
    }
    else if \"sshsudo_payload_msg1\" not in [tags] {
        if [log][level] == \"informational\" or [log][level] == \"debug\" or [log][level] == \"notice\" {
            if [process][name] not in [ \"audit_protocol\", \"audispd\", \"vmauthd\" ] {
                if [message] !~ /(?i)login/ or [message] !~ /(?i)logged/ or [message] !~ /(?i)fail/ or [message] !~ /(?i)error/ or [log][facility] !~ /security\\/authorization/ or [message] !~ /(?i)failed/ {
                    mutate {
                        add_tag => [ \"dropped-loginsight\" ]
                    }
                    drop{}
                }
            }
        }
    }
}

output {

    if [@metadata][pipeline] {
        elasticsearch {
            hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
            index => \"%{[@metadata][index]}\"
            pipeline => \"%{[@metadata][pipeline]}\"
            user => \"ls_internal\"
            password => \"${LS_INTERNAL_PW}\"
            ssl => true
            cacert => \"/etc/logstash/certs/cachain.pem\"
        }
    }
    else if \"malformed\" in [tags] {
        elasticsearch {
            hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
            index => \"dcgs-unparsed-syslog-iaas-ent\"
            user => \"ls_internal\"
            password => \"${LS_INTERNAL_PW}\"
            ssl => true
            cacert => \"/etc/logstash/certs/cachain.pem\"
        }
    }
    else if \"dropped-loginsight\" in [tags] {
        elasticsearch {
            hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
            index => \"dcgs-loginsight_syslog-iaas-ent\"
            user => \"ls_internal\"
            password => \"${LS_INTERNAL_PW}\"
            ssl => true
            cacert => \"/etc/logstash/certs/cachain.pem\"
        }
    }
    else {
        elasticsearch {
            hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
            index => \"dcgs-syslog_loginsight-iaas-ent-${SITENUM}\"
            user => \"ls_internal\"
            password => \"${LS_INTERNAL_PW}\"
            ssl => true
            cacert => \"/etc/logstash/certs/cachain.pem\"
        }
    }
}","settings":{"pipeline.batch.delay":50,"pipeline.batch.size":2750,"pipeline.workers":8,"queue.checkpoint.writes":1024,"queue.max_bytes":"25gb","queue.type":"persisted"}}
