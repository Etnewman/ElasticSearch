{"description":"Linux syslog pipeline provided by Enterprise Services","pipeline":"input {
    tcp {
        port => 5041
        ssl_enable => true
        ssl_certificate_authorities => [\"/etc/logstash/certs/cachain.pem\"]
        ssl_cert => \"/etc/logstash/certs/${HOSTNAME}.crt\"
        ssl_key => \"/etc/logstash/certs/${HOSTNAME}_pkcs8.key\"
        ssl_key_passphrase => \"${SSL_PASSPHRASE}\"
        ssl_verify => false
    }
}

filter {

    # Add Orignating Site to document
    mutate {
        add_field => { \"DCGS_Site\" => \"${SITE}\" }
        add_field => { \"DCGS_Site_Name\" => \"${SITELOC}\" }
        add_field => { \"[geo][name]\" => \"${SITELOC}\" }
    }
    translate {
        field => \"DCGS_Site_Name\"
        destination => \"[geo][location]\"
        override => \"true\"
        fallback => \"0,0\"
        dictionary_path => '/etc/logstash/dictionaries/site_coordinates.yml'
    }
    # Add time of ingest to event
    ruby {
        code => '
            event.set(\"[event][ingested]\", Time.now())
        '
    }

    if [host] {
        mutate {
            rename => { \"host\" => \"[log][syslog][source][host]\" }
            rename => { \"port\" => \"[log][syslog][source][port]\" }
        }
    }

    # Add tag to events with an associated ingest pipeline so it can be skipped
    if [@metadata][pipeline] {
        mutate {
            add_tag => [ \"dnt_par\" ]
            id => \"dont_par\"
        }
    }

    # Copy original data and clear hostname
    mutate {
        copy => { \"@timestamp\" => \"[event][created]\" }
        copy => { \"message\" => \"[event][original]\" }
        remove_field => [ \"[host][name]\" ]
        id => \"mod_orig\"
    }



    # Parse the header portion of event for syslog priority code, syslog version, and date
    grok {
        match => {
            \"message\" => [
                \"^(?:<(?<[log][syslog][priority]>[0-9]{1,3})>)(?:(?<[log][syslog][version]>[0-9]{1,2}))? ?(?:%{SYSLOGTIMESTAMP:ts}|%{TIMESTAMP_ISO8601:ts}|(?<ts>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(UTC)?)|(?<ts>[a-zA-Z]{3}\\s+[0-9]{1,2}\\s[0-9]{2}:[0-9]{2}:[0-9]{2})) %{GREEDYDATA:payload_msg}\"
            ]
        }
        add_tag => [ \"header_parsed0\" ]
        id => \"parse_header0\"
        tag_on_failure => [ \"malformed\" ]
    }

    if \"dont_par\" not in [tags] and \"malformed\" not in [tags] {
        # Parse event for hostname, process name, and pid
        if \"header_parsed0\" in [tags] {
            grok {
                match => {
                    \"payload_msg\" => [
                        \"^%{IPORHOST:[host][name]} (?:-|\\[?%{PROG:[process][name]}\\]?) +(?:-|(?<[process][pid]>[0-9]{1,8})) +(?:-|%{DATA:[log][syslog][msgid]}) +(?:-|\\[%{DATA:payload_sd}\\]) +%{GREEDYDATA:payload_msg1}\",
                        \"^%{IPORHOST:[host][name]}? (?:%{PROG:[process][name]})(?:\\[(?<[process][pid]>[0-9]{1,8})\\]):? +%{GREEDYDATA:payload_msg1}\",
                        \"^%{IPORHOST:[host][name]} (?:%{PROG:[process][name]})\\[?\\]?: +%{GREEDYDATA:payload_msg1}\",
                        \"^%{IPORHOST:[host][name]} (?:%{PROG:[process][name]})?\\[?\\]? +%{GREEDYDATA:payload_msg1}\",
                        \"^%{IPORHOST:[host][name]} +%{GREEDYDATA:payload_msg1}\"
                    ]
                }
                add_tag => [ \"header_parsed1\" ]
                id => \"parse_header1\"
            }
            # Lowercase hostname and process name
            mutate {
                lowercase => [ \"[process][name]\", \"[host][name]\" ]
                id => \"lowercase\"
            }
            if [host][name] =~ /^[a-zA-Z]{1}[0-9a-fA-F]{2}(su|wu)[0-9]{2}[a-zA-Z]+[0-9]/ {
                mutate {
                    add_tag => [\"Linux\"]
                }
            }
        }

        if [payload_sd] {
            if [payload_sd] =~ /^.*@/ {
                grok {
                    match => { \"payload_sd\" => \"%{DATA:[log][syslog][sd-id]} %{GREEDYDATA}\" }
                }
            }

            kv {
                source => \"payload_sd\"
                target => \"Log\"
                transform_key => \"lowercase\"
            }
        }


    # Parse syslog priority code
    if [log][syslog][priority] {
        syslog_pri {
            ecs_compatibility => v8
        }

        mutate {
            copy => { \"[log][syslog][facility][name]\" => \"[log][facility]\" }
            copy => { \"[log][syslog][severity][name]\" => \"[log][level]\" }
            id => \"syslog_field_rename\"
        }

        # Add severity code to event
        if ![event][severity] {
            mutate {
                copy => { \"[log][syslog][severity][code]\" => \"[event][severity]\" }
            }
        }
    }
    else {
        mutate {
            add_tag => [ \"no_syslog_priority\" ]
        }
    }

    # Parse auditd events events by formatting event and adding pipeline info
    if [payload_msg1] =~ \"msg=audit\" and [payload_msg1] =~ /^node/ {
        grok {
            match => { \"payload_msg1\" => \"node=%{HOSTNAME:[host][hostname]}\" }
        }

        if [auditd][log][addr] == \"UNKNOWN\" {
            mutate {
                remove_field => [ \"[auditd][log][addr]\" ]
            }
        }

        if [payload_msg1] =~ /msg='op/ {
            grok {
                match => {
                    \"payload_msg1\" => \"%{GREEDYDATA}msg='op=%{DATA:[auditd][log][op]} %{GREEDYDATA}\"
                }
            }
        }

        # Ensure metadata fields for auditd events are added
        mutate {
            add_field => { \"[@metadata][pipeline]\" => \"filebeat-${VER}-auditd-log-pipeline\" }
            add_field => { \"[@metadata][index]\" => \"dcgs-audits_syslog-iaas-ent-${SITENUM}\" }
            add_field => { \"[event][module]\" => \"auditd\" }
            add_field => { \"[event][dataset]\" => \"auditd.log\" }
            rename => { \"[process][name]\" => \"[process][parent][name]\" }
            id => \"auditd_parse\"
            add_tag => [ \"auditd_parsed\" ]
        }
    }
    # Add puppet.Reason
    if [process][name] == \"puppet-agent\" and [payload_msg1] =~ /^Skipping run of Puppet configuration client; administratively disabled/ {
        grok {
            match => {
                \"payload_msg1\" => \"%{GREEDYDATA} \\(Reason: '%{GREEDYDATA:[puppet][Reason]}'\\);\"
            }
        }
    }
    # Parse iptables events by formatting event and adding pipeline info
    if [process][name] in [ \"kernel\", \"firewall\" ] and [payload_msg1] =~ /^\\[(IPTABLES|default|DEFAULT)\\]/ {
        grok {
            match => {
                \"payload_msg1\" => \"%{GREEDYDATA:[iptables][log_prefix]}IN=%{GREEDYDATA}\"
            }
        }

        grok {
            match => {
                \"[event][original]\" => \"<%{NUMBER}>%{GREEDYDATA:message_No_Pri}\"
            }
        }

        if [iptables][log_prefix] =~ /DROP/ {
            mutate {
                add_field => { \"[iptables][action]\" => \"drop\" }
                add_field => { \"[event][outcome]\" => \"deny\" }
                add_field => { \"[event][action]\" => \"firewall-deny\" }
            }
        }

        # Ensure metadata fields for iptables or firewall events are added, includes specifics for VMWare \"firewall\"
        if [process][name] == \"kernel\" {
            mutate {
                rename => { \"[process][name]\" => \"[event][provider]\" }
                add_field => { \"[process][name]\" => \"iptables\" }
                id => \"iptable_parse\"
                add_tag => [ \"iptable_parsed\" ]
            }
        }

        if [process][name] == \"firewall\" {
            mutate {
                add_field => { \"comment\" => \"Using iptables logs pipeline due to its similarity with VMWare firewall logs\" }
                id => \"firewall_parse\"
                add_tag => [ \"firewall_parsed\" ]
            }
        }

        mutate {
            copy => { \"ts\" => \"[iptables][raw_date]\" }
            add_field => { \"[event][kind]\" => \"alert\" }
            add_field => { \"[event][module]\" => \"iptables\" }
            add_field => { \"[event][dataset]\" => \"iptables.log\" }
            add_field => { \"[@metadata][pipeline]\" => \"filebeat-${VER}-iptables-log-pipeline\" }
            add_field => { \"[@metadata][index]\" => \"dcgs-iptables-iaas-ent\" }
        }
    }

    # Parse authentication logs from sudo, sshd, and su
    if [process][name] in [ \"sshd\", \"sudo\", \"su\", \"systemd-logind\" ] {
        grok {
            match => {
                \"payload_msg1\" => [
                    \"%{DATA:[system][auth][module]}\\(sshd:auth\\): %{DATA:[system][auth][ssh][event]} %{DATA:[system][auth][ssh][outcome]}; logname=%{DATA:[system][auth][ssh][logname]}? uid=%{NUMBER:[system][auth][ssh][uid]}? euid=%{NUMBER:[system][auth][ssh][euid]}? tty=%{DATA:[system][auth][ssh][tty]}? ruser=%{DATA:[system][auth][ssh][remote_user]}? rhost=%{DATA:[system][auth][ssh][remote_host]}? user=%{GREEDYDATA:[system][auth][ssh][user]}?\",
                    \"%{DATA:[system][auth][module]}\\(sudo:auth\\): %{DATA:[system][auth][sudo][event]} %{DATA:[system][auth][sudo][outcome]}; logname=%{DATA:[system][auth][sudo][logname]}? uid=%{NUMBER:[system][auth][sudo][uid]}? euid=%{NUMBER:[system][sudo][ssh][euid]}? tty=%{DATA:[system][auth][sudo][tty]}? ruser=%{DATA:[system][auth][sudo][remote_user]}? rhost=%{DATA:[system][auth][sudo][remote_host]}? user=%{GREEDYDATA:[system][auth][sudo][user]}?\",
                    \"%{DATA:[system][auth][ssh][event]} %{DATA:[system][auth][ssh][method]} for (invalid user )?%{DATA:[user][name]} from %{IPORHOST:[source][ip]} port %{NUMBER:[source][port]:long} ssh2(: %{GREEDYDATA:[system][auth][ssh][signature]})?\",
                    \"%{DATA:[system][auth][ssh][event]} user %{DATA:[user][name]} from %{IPORHOST:[source][ip]}\",
                    \"\\s*%{DATA:[user][name]} :( %{DATA:[system][auth][sudo][error]} ;)? TTY=%{DATA:[system][auth][sudo][tty]} ; PWD=%{DATA:[system][auth][sudo][pwd]} ; USER=%{DATA:[system][auth][sudo][user]} ; COMMAND=%{GREEDYDATA:[system][auth][sudo][command]}\",
                    \"new group: name=%{DATA:[group][name]}, GID=%{NUMBER:[group][id]}\",
                    \"new user: name=%{DATA:[user][name]}, UID=%{NUMBER:[user][id]}, GID=%{NUMBER:[group][id]}, home=%{DATA:[system][auth][useradd][home]}, shell=%{DATA:[system][auth][useradd][shell]}$\",
                    \"%{DATA:[system][auth][ssh][event]} from %{IP:[source][ip]}\",
                    \"%{GREEDYDATA:payload_msg2}\"
                ]
            }
        }

        if ![system][auth][sudo][event] {
            if [system][auth][ssh][event] not in [ \"success\", \"failure\" ] {
                translate {
                    field => \"[system][auth][ssh][event]\"
                    destination => \"[system][auth][ssh][outcome]\"
                    dictionary => {
                        \"Accepted\" => \"success\"
                        \"Failed\" => \"failure\"
                        \"Invalid\" => \"failure\"
                    }
                }
                mutate {
                    replace => { \"[system][auth][ssh][event]\" => \"authentication\" }
                }
            }
        }

        if ![system][auth][ssh][event] {
            if [system][auth][sudo][event] not in [ \"success\", \"failure\", \"Did not\" ] {
                translate {
                    field => \"[system][auth][sudo][event]\"
                    destination => \"[system][auth][sudo][outcome]\"
                    dictionary => {
                        \"Did not receive identification string\" => \"failure\"
                        \"Accepted\" => \"success\"
                        \"Failed\" => \"failure\"
                        \"Invalid\" => \"failure\"
                    }
                }
                mutate {
                    replace => { \"[system][auth][sudo][event]\" => \"authentication\" }
                }
            }
        }

        if [system][auth][ssh][outcome] {
            mutate {
                add_field => { \"[event][type]\" => \"authentication_%{[system][auth][ssh][outcome]}\" }
            }
        }

        if [system][auth][ssh][event] {
            mutate {
                copy => { \"[system][auth][ssh][dropped_ip]\" => \"[source][ip]\" }
                copy => { \"[system][auth][ssh][event]\" => \"[event][category]\" }
                copy => { \"[system][auth][ssh][outcome]\" => \"[event][outcome]\" }
                copy => { \"[system][auth][ssh][logname]\" => \"[user][logname]\" }
                copy => { \"[system][auth][ssh][uid]\" => \"[user][id]\" }
                copy => { \"[system][auth][ssh][euid]\" => \"[user][effective][id]\" }
                copy => { \"[system][auth][ssh][tty]\" => \"[user][terminal]\" }
                copy => { \"[system][auth][ssh][remote_user]\" => \"[user][remote][name]\" }
                copy => { \"[system][auth][ssh][remote_host]\" => \"[source][Host]\" }
                copy => { \"[system][auth][ssh][user]\" => \"[user][name]\" }
            }
        }

        if \"[system][auth][sudo][event]\" {
            mutate {
                copy => { \"[system][auth][sudo][event]\" => \"[event][category]\" }
                copy => { \"[system][auth][sudo][outcome]\" => \"[event][outcome]\" }
                copy => { \"[system][auth][sudo][logname]\" => \"[user][logname]\" }
                copy => { \"[system][auth][sudo][uid]\" => \"[user][id]\" }
                copy => { \"[system][auth][sudo][euid]\" => \"[user][effective][id]\" }
                copy => { \"[system][auth][sudo][tty]\" => \"[user][terminal]\" }
                copy => { \"[system][auth][sudo][remote_user]\" => \"[user][remote][name]\" }
                copy => { \"[system][auth][sudo][remote_host]\" => \"[source][Host]\" }
                copy => { \"[system][auth][sudo][user]\" => \"[user][name]\" }
            }
        }

        mutate  {
            add_field => { \"[event][module]\" => \"system\" }
            add_field => { \"[event][dataset]\" => \"system.auth\" }
            add_tag => [ \"auth_parsed\" ]
            id => \"auth_parse\"
        }
    }

    if [process][name] =~ /]$/ {
        # For parsing example: [sssd[ldap_child[2234]]]
        if [process][name] =~ /^\\[/ {
            dissect {
                mapping => {
                    \"[process][name]\" => \"[%{[process][name]}[%{[process][child][name]}[%{[process][pid]}]]]\"
                }
            }
        }
        else {
            dissect {
                mapping => {
                    \"[process][name]\" => \"%{[process][name]}[%{[process][pid]}]\"
                }
            }
        }
    }

    #   Parse mongod events
    if [process][name] == \"mongod\" and [log][facility] == \"user-level\" {
        mutate {
            gsub => [ \"payload_msg1\", \"tags\",  \"Msg-tags\" ]
        }

        json {
            source => \"payload_msg1\"
            target => \"Log\"
        }
        if [Log][ts][$date] {
            mutate {
                rename => { \"[Log][ts]\" => \"[Log][tsobj]\" }
                copy => { \"[Log][tsobj][$date]\" => \"ts\" }
            }
        }
        mutate {
            merge => { \"tags\" => \"Msg-tags\" }
        }
    }

    #   Parse json events
    if [process][name] == \"etcd\" or [process][name] == \"kibana\" {
        mutate {
            gsub => [ \"payload_msg1\", \"tags\",  \"Msg-tags\" ]
        }

        json {
            source => \"payload_msg1\"
            target => \"Log\"
        }
        if [Log][ts][$date] {
            mutate {
                rename => { \"[Log][ts]\" => \"[Log][tsobj]\" }
                copy => { \"[Log][tsobj][$date]\" => \"ts\" }
            }
        }
        mutate {
            merge => { \"tags\" => \"Msg-tags\" }
        }
    }

    # Add tag and app_data for Guardian events
    if [process][name] == \"siris-proxy\" or [process][name] == \"guardian-client\" or [process][name] == \"siris-csv-converter\" or [process][name] == \"siris-websockets\" or [process][name] == \"siris-proxy\" or [process][name] == \"siris-geo-converter\" {
        mutate {
            add_tag => [ \"Guardian\" ]
            add_field => {
                \"[app][Kind]\" => \"Mission\"
                \"[app][Category]\" => \"GEOINT\"
                \"[app][Type]\" => \"HA\"
                \"[app][Name]\" => \"Guardian\"
                \"[app][DocType]\" => \"syslog\"
            }
        }
    }

    # \tFor parsing example: run-parts(/etc/cron.hourly)[1161
    if [process][name] =~ /^run.*\\d$/ {
        dissect {
            mapping => {
                \"[process][name]\" => \"%{[process][name]}[%{[process][pid]}\"
            }
        }
    }

     # Set time from event as @timestamp
    date {
        match => [ \"ts\", \"ISO8601\", \"MMM dd HH:mm:ss\", \"MMM d HH:mm:ss\", \"MMM  d HH:mm:ss\" ]
        target => \"@timestamp\"
    }

    # Added for debugging events with incorrect pid field
    if [process][pid] {
        if [process][pid] =~ /^[0-9]+$/ {
        }
        else {
            mutate {
                copy => { \"[process][pid]\" => \"[process][name][sub]\" }
                remove_field => [ \"[process][pid]\" ]
                add_tag => [ \"wrong_pid\" ]
                id => \"pid_debug\"
            }
        }
    }

    if ![host][hostname] {
        mutate {
            copy => { \"[host][name]\" => \"[host][hostname]\" }
        }
    }

    # Clean up unused fields and move processed event message to message field
    if [payload_msg2] {
        mutate {
            rename => { \"payload_msg2\" => \"message\" }
            remove_field => [ \"payload_msg\", \"payload_msg1\" ]
        }
    }
    else if [payload_msg1] and \"iptables\" not in [event][module] {
        mutate {
            rename => { \"payload_msg1\" => \"message\" }
            remove_field => [ \"payload_msg\" ]
        }
    }
    else if [message_No_Pri] {
        mutate {
            rename => { \"message_No_Pri\" => \"message\" }
            remove_field => [ \"payload_msg1\", \"payload_msg\" ]
        }
    }
    else {
        mutate {
            rename => { \"payload_msg\" => \"message\" }
        }
    }

    # Clean up unused fields and move processed event message to message field
    mutate {
        remove_field => [ \"ts\", \"beats_input_codec_plain_applied\", \"payload_sd\", \"tsobj.$date\" ]
    }

#    if [@metadata][pipeline] {
#        mutate {
#            add_field => { \"debug-pipeline-used\" => \"%{[@metadata][pipeline]}\" }
#            copy => { \"message\" => \"debug-message\"}
#        }
#    }
#    else {
#        mutate {
#            add_field => { \"debug-pipeline-used\" => \"None\" }
#        }
#    }

    # Remove tags used for debugging
    mutate {
        remove_tag => [ \"header_parsed0\", \"header_parsed1\", \"beats_input_codec_plain_applied\", \"auth_parsed\" ]
    }

    # Move level to log.level
    if [level] {
        mutate {
            copy => { \"[level]\" => \"[log][level]\" }
        }
    }

    if [log][level] == \"info\" {
        mutate {
            update => { \"[log][level]\" =>  \"informational\"}
                add_tag => [ \"Updated-level\" ]
        }
    }
    else if [log][level] == \"err\" {
        mutate {
            update => { \"[log][level]\" => \"error\" }
        }
    }
    else if [log][level] == \"warn\" {
        mutate {
            update => { \"[log][level]\" => \"warning\" }
        }
    }

    # remove the units (ms, seconds, s) from integer fields
    mutate {
       gsub => [
            \"exceeded-duration\", \"\\D\", \"\",
            \"clock-drift\", \"\\D\", \"\",
            \"expected-duration\", \"\\D\", \"\",
            \"heartbeat-interval\", \"\\D\", \"\",
            \"rtt\", \"\\D\", \"\",
            \"took\", \"\\D\", \"\"
        ]
    }

    }
}

output {
  if [@metadata][pipeline] {
    elasticsearch {
        hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
        index => \"%{[@metadata][index]}\"
        pipeline => \"%{[@metadata][pipeline]}\"
        user => \"ls_internal\"
        password => \"${LS_INTERNAL_PW}\"
        ssl => true
        cacert => \"/etc/logstash/certs/cachain.pem\"
    }
  }
  else if \"malformed\" in [tags] {
    elasticsearch {
        hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
        index => \"dcgs-unparsed-syslog-iaas-ent\"
        user => \"ls_internal\"
        password => \"${LS_INTERNAL_PW}\"
        ssl => true
        cacert => \"/etc/logstash/certs/cachain.pem\"
    }
  }
    else {
      elasticsearch {
        hosts => [\"${OUTPUT1}\", \"${OUTPUT2}\", \"${OUTPUT3}\"]
        index => \"dcgs-syslog-iaas-ent-${SITENUM}\"
        user => \"ls_internal\"
        password => \"${LS_INTERNAL_PW}\"
        ssl => true
        cacert => \"/etc/logstash/certs/cachain.pem\"
      }
    }
}","settings":{"pipeline.batch.delay":50,"pipeline.batch.size":1000,"pipeline.workers":3,"queue.checkpoint.writes":1024,"queue.max_bytes":"125gb","queue.type":"persisted"}}
